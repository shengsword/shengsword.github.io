<!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>Introduction</title>
            <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

</style>
            <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
<style>
:root {
  --color-note: #0969da;
  --color-tip: #1a7f37;
  --color-warning: #9a6700;
  --color-severe: #bc4c00;
  --color-caution: #d1242f;
  --color-important: #8250df;
}

</style>
<style>
@media (prefers-color-scheme: dark) {
  :root {
    --color-note: #2f81f7;
    --color-tip: #3fb950;
    --color-warning: #d29922;
    --color-severe: #db6d28;
    --color-caution: #f85149;
    --color-important: #a371f7;
  }
}

</style>
<style>
.markdown-alert {
  padding: 0.5rem 1rem;
  margin-bottom: 16px;
  color: inherit;
  border-left: .25em solid #888;
}

.markdown-alert>:first-child {
  margin-top: 0
}

.markdown-alert>:last-child {
  margin-bottom: 0
}

.markdown-alert .markdown-alert-title {
  display: flex;
  font-weight: 500;
  align-items: center;
  line-height: 1
}

.markdown-alert .markdown-alert-title .octicon {
  margin-right: 0.5rem;
  display: inline-block;
  overflow: visible !important;
  vertical-align: text-bottom;
  fill: currentColor;
}

.markdown-alert.markdown-alert-note {
  border-left-color: var(--color-note);
}

.markdown-alert.markdown-alert-note .markdown-alert-title {
  color: var(--color-note);
}

.markdown-alert.markdown-alert-important {
  border-left-color: var(--color-important);
}

.markdown-alert.markdown-alert-important .markdown-alert-title {
  color: var(--color-important);
}

.markdown-alert.markdown-alert-warning {
  border-left-color: var(--color-warning);
}

.markdown-alert.markdown-alert-warning .markdown-alert-title {
  color: var(--color-warning);
}

.markdown-alert.markdown-alert-tip {
  border-left-color: var(--color-tip);
}

.markdown-alert.markdown-alert-tip .markdown-alert-title {
  color: var(--color-tip);
}

.markdown-alert.markdown-alert-caution {
  border-left-color: var(--color-caution);
}

.markdown-alert.markdown-alert-caution .markdown-alert-title {
  color: var(--color-caution);
}

</style>
        
        </head>
        <body class="vscode-body vscode-light">
            <h2 id="introduction">Introduction</h2>
<p>In the previous lesson, we learned how to generate primary rays, but we haven't been able to produce an image yet, because we haven't learned how to calculate the intersection of these primary rays with any geometry. In this lesson, we will learn about computing the ray-geometry intersection for simple shapes such as spheres. Spheres are easy to ray-trace, which is why they are often used by people learning how to program a ray tracer. So this lesson will be a little bit of a mismatch of topics:</p>
<ul>
<li>In this chapter, we will learn about parametric and implicit surfaces. These surfaces or shapes are special in that they can be mathematically defined. This is the base of the technique we will study in the next chapter to calculate their intersection against rays.</li>
<li>In chapter 2, we will learn about a couple of techniques to calculate the intersection of a ray with a sphere.</li>
<li>In chapter 3, we will put together what we learned in the previous lesson about generating primary rays and what we learned in chapter 2 of this lesson to calculate whether primary rays intersect any of the spheres making up the scene. The program we will develop for this lesson will form the base of a minimal but functional ray tracer. First, we will learn about the <code>trace()</code> function. This is where we test each sphere against the primary ray and return the intersection distance and a pointer to the closest intersected sphere (if the ray intersected a sphere at all). Then, in the <code>castRay()</code> function, we will also learn how to use the normal and texture coordinates at the intersection point to perform some simple shading.</li>
<li>Finally, in chapters 4 and 5, we will learn about various techniques to calculate the intersection of a ray with other simple shapes such as planes, disks, and axis-aligned boxes.</li>
<li>As usual, the last chapter of this lesson contains the full source code of all the programs developed for this lesson (with instructions on how to compile them).</li>
</ul>
<h2 id="ray-geometry-intersection">Ray-Geometry Intersection</h2>
<p>In the previous lesson, we learned how to generate primary rays. Next, we must learn about the ray-geometry intersection to produce an image. The idea is to use mathematics to find if a ray intersects an object. As often mentioned in the previous lessons, geometry or 3D objects can be described in many different ways in CG. For example, we already mentioned polygon meshes (which are made of faces), NURSBs surfaces, subdivision surfaces, etc. though apart from triangular meshes, which are a subset of polygon meshes, we still need to study what NURBS and subdivision surfaces are.</p>
<p>These types of geometry are useful in computer graphics because they are good at describing the shape of complex objects. Simple shapes such as spheres, planes, disks, or boxes can be rendered directly using simpler methods. These shapes can be described mathematically by equations, and we can use these equations to calculate whether a ray intersects them analytically. This is what we will learn about in this lesson.</p>
<p>How can a shape be defined mathematically? This can be done in generally two different ways: <strong>parametrically</strong> and <strong>implicitly</strong>.</p>
<h2 id="parametric-surfaces">Parametric Surfaces</h2>
<p><img src="file:////images/ray-simple-shapes/impsurf-ray.png" alt="Figure 1: parametric definition of a ray."></p>
<p>If you remember what we said in the previous lesson, rays too can be defined using the following <a href="http://en.wikipedia.org/wiki/Parametric_equation"><strong>parametric equation</strong></a>:</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>P</mi><mo>=</mo><mi>O</mi><mo>+</mo><mi>t</mi><mi>D</mi></mrow><annotation encoding="application/x-tex">P = O + t D
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span></span></p>
<p>Where (P) is a point on the ray half-line, (O) is the ray origin, and (D) is the ray direction. The term (t) is called a parameter. By changing the value of (t), we can describe as many points on the ray half-line as we want, and the collection of these points forms the half-line itself. In other words, it describes generating an ordered sequence of points along the ray. Spheres, too, can be defined using a parametric form. Here is the parametric equation of a sphere:</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.16em" columnalign="left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>P</mi><mi mathvariant="normal">.</mi><mi>x</mi><mo>=</mo><mi>cos</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo><mi>sin</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>ϕ</mi><mo stretchy="false">)</mo><mo separator="true">,</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>P</mi><mi mathvariant="normal">.</mi><mi>y</mi><mo>=</mo><mi>cos</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo><mo separator="true">,</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>P</mi><mi mathvariant="normal">.</mi><mi>z</mi><mo>=</mo><mi>sin</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo><mi>sin</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>ϕ</mi><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{array}{l}
P.x = \cos(\theta)\sin(\phi),\\
P.y = \cos(\theta),\\
P.z = \sin(\theta)\sin(\phi).\\
\end{array}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.6em;vertical-align:-1.55em;"></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord">.</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mop">cos</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">sin</span><span class="mopen">(</span><span class="mord mathnormal">ϕ</span><span class="mclose">)</span><span class="mpunct">,</span></span></span><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mop">cos</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mpunct">,</span></span></span><span style="top:-1.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mop">sin</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">sin</span><span class="mopen">(</span><span class="mord mathnormal">ϕ</span><span class="mclose">)</span><span class="mord">.</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span></span></span></p>
<details>
The equations to calculate Cartesian coordinates from spherical coordinates may vary from source to source. It depends on the convention being used for naming the coordinate system axes and whether \(\theta\) defines the polar or azimuthal angle. In the example above, y is the up axis, x points to the right, and z is in a plane perpendicular to y. \(\theta\) defines the polar angle as shown in figure 2.
</details>
<p><img src="file:////images/ray-simple-shapes/impsurf-sphere.png?" alt="Figure 2: parametric definition of a sphere."></p>
<p>Or:</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.16em" columnalign="left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mover accent="true"><mi>r</mi><mo>⃗</mo></mover><mo stretchy="false">(</mo><mi>θ</mi><mo separator="true">,</mo><mi>ϕ</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>cos</mi><mo>⁡</mo><mi>θ</mi><mi>sin</mi><mo>⁡</mo><mi>ϕ</mi><mo separator="true">,</mo><mi>cos</mi><mo>⁡</mo><mi>θ</mi><mo separator="true">,</mo><mi>sin</mi><mo>⁡</mo><mi>θ</mi><mi>sin</mi><mo>⁡</mo><mi>ϕ</mi><mo stretchy="false">)</mo><mo separator="true">,</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>0</mn><mo>≤</mo><mi>θ</mi><mo>&lt;</mo><mn>2</mn><mi>π</mi><mo separator="true">,</mo><mn>0</mn><mo>≤</mo><mi>ϕ</mi><mo>≤</mo><mi>π</mi><mi mathvariant="normal">.</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{array}{l}
\vec r(\theta,\phi) = (\cos\theta \sin\phi, \cos\theta, \sin\theta \sin \phi), \\
0 \leq \theta &lt; 2\pi, 0 \leq \phi \leq \pi.
\end{array}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1799em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">ϕ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mopen">(</span><span class="mop">cos</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">sin</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">ϕ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">cos</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">sin</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">sin</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">ϕ</span><span class="mclose">)</span><span class="mpunct">,</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">ϕ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mord">.</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span></span></span></p>
<p>Where (\theta) and (\phi) are a point's latitude and longitude coordinates on a sphere defined in radians. The angle (\theta) (the Greek letter <em>theta</em>) is contained in the range [0, (\pi)], and than angle (\phi) (the greek letter <em>phi</em>) is contained in the range [0, (2\pi)]. We have already introduced these equations in the lesson on <a href="/lessons/mathematics-physics-for-computer-graphics/geometry/spherical-coordinates-and-trigonometric-functions">Geometry</a>. The coordinates (\theta, \phi) of a point on a sphere, are also known as <a href="http://en.wikipedia.org/wiki/Spherical_coordinate_system">spherical coordinates</a>. What's important here, though, is that a sphere can be described using a set of three equations. In these parametric equations, (\theta) and (\phi) are the parameters. 3D objects that can be defined using such equations are called <strong><a href="http://en.wikipedia.org/wiki/Parametric_surface">parametric surfaces</a></strong>.</p>
<p>In CG, this representation is useful because the two parameters (\theta) and (\phi) are often denoted (u) and (v) or (s) and (t) in the generic case, can be used as the texture coordinates of a point on the 3D surface of the object. For example, in the case of a sphere, we can easily remap the two parameters (\theta) and (\phi) to the range [0, 1] and use these coordinates to perform a lookup in a texture or generate a pattern using a procedural approach. An example of this technique will be provided in this lesson (<a href="/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/minimal-ray-tracer-rendering-spheres">chapter 3</a>). In other words, the process can be seen as some mapping from 2D space to 3D space (and we use the 2D coordinates for texturing, as our st coordinates).</p>
<p>In general, what you need to remember about parametric surfaces, is that it requires 1 parameter to describe a curve and two parameters to describe a 3D surface.</p>
<h2 id="implicit-surfaces">Implicit Surfaces</h2>
<p><img src="file:////images/ray-simple-shapes/impsurf-circle.png?" alt="Figure 3: implicit form of a circle of radius r."></p>
<p>Implicit surfaces are very similar to parametric surfaces. To start with, we will be using the example of a circle which in its implicit form is defined by the following equation:</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><msup><mi>y</mi><mn>2</mn></msup><mo>=</mo><msup><mi>r</mi><mn>2</mn></msup><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">x^2 + y^2 = r^2.
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9474em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0585em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8641em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord">.</span></span></span></span></span></p>
<p>Where (x) and (y) are the coordinates of a point in 2D space, and (r) is the radius of the circle (figure 1). All it says is that the equation above is true for any points lying in a circle of radius (r). In other words, if you take the coordinates of any points on the circle or radius (r), raise these coordinates to the power of 2, and sum them up, then you will get a number that is equal to the radius of the circle raised to the power of 2. Note that in this example, the circle is assumed to be centered around the origin. Though you can generalize this equation to circles with arbitrary center positions:</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><msup><mi>x</mi><mn>2</mn></msup><mo>−</mo><msubsup><mi>O</mi><mi>x</mi><mn>2</mn></msubsup><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><msup><mi>y</mi><mn>2</mn></msup><mo>−</mo><msubsup><mi>O</mi><mi>y</mi><mn>2</mn></msubsup><mo stretchy="false">)</mo><mo>=</mo><msup><mi>r</mi><mn>2</mn></msup><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">(x^2 - O_x^2) + (y^2 - O_y^2) = r^2.
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1141em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.1141em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-2.453em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.1141em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.2472em;vertical-align:-0.3831em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-2.453em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3831em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8641em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord">.</span></span></span></span></span></p>
<p>Where (O) is the circle center position. All this equation does, though, is &quot;move&quot; the center of the circle to the origin. The equation above is the implicit equation of a circle. The concept can easily be extended to 3D. The implicit equation of the sphere is as follows:</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><msup><mi>y</mi><mn>2</mn></msup><mo>+</mo><msup><mi>z</mi><mn>2</mn></msup><mo>=</mo><msup><mi>r</mi><mn>2</mn></msup><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">x^2 + y^2 + z^2 = r^2.
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9474em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0585em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8641em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8641em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord">.</span></span></span></span></span></p>
<p>The concept is the same. The equation will be true for all points lying on the sphere of radius (r).</p>
<p><img src="file:////images/ray-simple-shapes/impsurf-bounding-sphere.png?" alt="Figure 4: using a sphere as a bounding volume to test whether a ray may intersect the enclosed geometry. If the ray doesn't intersect the sphere, then we know it can't intersect the object."></p>
<p>In this lesson, we will learn how these equations can be used to test the intersection of a ray with an implicit surface.</p>
<p>Many shapes can be defined with such equations as planes, spheres, cones, tori, etc. You might think these shapes could be more useful to describe the shape of complex objects, which would be true. This is what we said in the introduction of this lesson. Rendering spheres might be useful for testing your program but are limited indeed. But they can be useful in other contexts. For example, spheres can represent an object's overall volume, <strong>as a bounding volume</strong> (figure 4). If the enclosed object is very complex, testing if a ray intersects this object is likely to be computationally expensive. We can first check if the ray intersects the bounding sphere. If it doesn't, then we know that the ray can't intersect the enclosed object, which saves us the time it would have taken to test the intersection with the object itself. This method is only advantageous if the time it takes to calculate the ray-sphere intersection is less than the time it takes to calculate the intersection of the ray with the enclosed object. The good news is the cost of an intersection test between a ray and an implicit surface is often less than a ray-triangle intersection test, for example. If the scene contains many such complex objects, this simple ray-geometry acceleration method can save us a lot of computation time. In conclusion, learning about implicit surfaces and how they can be used to calculate ray-geometry intersections is still very useful despite the simplicity of their shapes.</p>
<details>
![](/images/ray-simple-shapes/blobbies.png)
Implicit surfaces and Blobies: one class of implicit surfaces is very interesting. They are called by many names in the CG literature: blobies, metaballs, etc. You can see blobies as little spheres which influence each other. If you can get two blobies close to each other, their surface will start to blend in the middle to form a larger blob. Blobies were a very popular modeling technique in the 1980s-1990s. They are very good at modeling organic shapes. However, blobies can only be ray-traced indirectly easily. They often require to be converted to a polygon mesh first. A lesson on blobies can be found in the modeling section.
</details>
<h2 id="why-are-these-surfaces-useful-in-ray-tracing">Why Are these Surfaces Useful in Ray-Tracing</h2>
<p>The topic of this lesson is to study how the property of being defined with an equation can be used to calculate the ray-geometry intersection test. Of course, implicit surfaces are less useful than parametric surfaces in computing this ray-geometry intersection test. Still, they are useful for computing the texture coordinates of a point lying on the surface of an implicit object (as explained in the next chapter). Thus knowing about both representations is still useful and needed. Moreover, they are useful for the reason we already mentioned above:</p>
<ul>
<li>The solution to a ray-implicit surface is often simpler to calculate than with another type of geometry.</li>
<li>The intersection of a ray with an implicit surface is often faster to calculate than with another geometry type.</li>
<li>The shapes are too simple to represent the shape of complex objects, but they can be used as bounding volumes, for instance, which can be used to accelerate ray-geometry intersection testing.</li>
<li>The ray-implicit surface intersection test is an example of practical use of mathematical concepts such as computing <a href="http://en.wikipedia.org/wiki/Quadratic_equation#Solving_the_quadratic_equation">the roots of a quadratic equation</a>.</li>
</ul>
<p>In this lesson, we will learn about the ray-sphere, ray-plane, ray-disk (an exertion of the ray-plane case), and ray-box intersection test. The sphere belongs to a category of surfaces called <strong>quadrics</strong>. Any quadrics (cones, torus, etc.) can be tested against a ray using the same solution as the solution we will describe for the sphere.</p>
<h2 id="integrate-and-differentiate-derivatives-tangents-and-normal-vectors">Integrate and Differentiate: Derivatives, Tangents, and Normal Vectors</h2>
<p>Another advantage of parametric or implicit surfaces is that the equations that define the shape of these surfaces can be used to calculate other useful values, such as the derivatives, the tangent, the bi-tangent, and the normal at any given point on the surface. We already know about normals and the role they play in shading. Derivatives at the surface of a point are also important for things such as texture filtering. Tangent and bi-tangent can also be used to form a local coordinate system at any given point on the object's surface, which is useful in shading. The mathematics involved in computing these values can be significantly more complex than the mathematics used in computing the intersection of a ray with an implicit surface. Therefore, it won't be studied in this lesson. If you are interested in this topic, you can search for differential geometry on the Web. A separate lesson will be devoted to this topic alone. We will use the normal in the next lessons, but shapes, such as spheres and triangles, are simpler to calculate the normal than using techniques from differential geometry.</p>
<h2 id="about-ray-tracing-spheres-and-writing-a-production-quality-ray-tracer">About Ray-Tracing Spheres and Writing a Production Quality Ray-Tracer</h2>
<p>The method we will learn about in this lesson to calculate the intersection of a ray with a sphere is different than the method we will study in the next lesson to calculate the ray-triangle intersection. As mentioned in a previous lesson, we generally avoid supporting several types of geometry in a renderer for many different reasons. First, because it requires writing more code, but more importantly, every feature supported by the program (motion blur, displacement, texture mapping, acceleration structure, etc.) needs to work with each supported geometry type which puts an additional constraint on the programmer. So, it is generally easier to support only one geometry type (triangle is the most common choice) and convert other geometry types to that type instead. Most production renderers provide a way of rendering simple shapes such as spheres, tori, etc., though the way they handle it internally is by converting these shapes to polygon meshes (generally using these shapes' parametric representation) rather than implementing a ray-geometry intersection routine specific to spheres and tori (we will learn how to convert a parametric surface to a polygon mesh in the lesson Ray-Tracing: <a href="/lessons/3d-basic-rendering/ray-tracing-polygon-mesh/">Ray-Tracing a Polygon Mesh</a>). The reality is that, in production, you rarely render spheres anyway. This is different from the approach we will use in this lesson. We will use the old-fashion or, say it differently, the native way of ray-tracing these shapes. Of course, the advantage of the method we will learn about in this lesson is that it doesn't require a conversion to a polygon mesh and that rendering a sphere using equations is much faster than ray-tracing a sphere made of 100, 1.000, or 10,000 triangles. Learning how to ray-trace spheres or quadric surfaces is good exercise. Still, practically, this is generally different than the way it is done in a production quality renderer.</p>

            <script async src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
            
        </body>
        </html>