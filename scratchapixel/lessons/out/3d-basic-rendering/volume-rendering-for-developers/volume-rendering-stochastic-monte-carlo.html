<!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>What we will study next</title>
            <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

</style>
            <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
<style>
:root {
  --color-note: #0969da;
  --color-tip: #1a7f37;
  --color-warning: #9a6700;
  --color-severe: #bc4c00;
  --color-caution: #d1242f;
  --color-important: #8250df;
}

</style>
<style>
@media (prefers-color-scheme: dark) {
  :root {
    --color-note: #2f81f7;
    --color-tip: #3fb950;
    --color-warning: #d29922;
    --color-severe: #db6d28;
    --color-caution: #f85149;
    --color-important: #a371f7;
  }
}

</style>
<style>
.markdown-alert {
  padding: 0.5rem 1rem;
  margin-bottom: 16px;
  color: inherit;
  border-left: .25em solid #888;
}

.markdown-alert>:first-child {
  margin-top: 0
}

.markdown-alert>:last-child {
  margin-bottom: 0
}

.markdown-alert .markdown-alert-title {
  display: flex;
  font-weight: 500;
  align-items: center;
  line-height: 1
}

.markdown-alert .markdown-alert-title .octicon {
  margin-right: 0.5rem;
  display: inline-block;
  overflow: visible !important;
  vertical-align: text-bottom;
  fill: currentColor;
}

.markdown-alert.markdown-alert-note {
  border-left-color: var(--color-note);
}

.markdown-alert.markdown-alert-note .markdown-alert-title {
  color: var(--color-note);
}

.markdown-alert.markdown-alert-important {
  border-left-color: var(--color-important);
}

.markdown-alert.markdown-alert-important .markdown-alert-title {
  color: var(--color-important);
}

.markdown-alert.markdown-alert-warning {
  border-left-color: var(--color-warning);
}

.markdown-alert.markdown-alert-warning .markdown-alert-title {
  color: var(--color-warning);
}

.markdown-alert.markdown-alert-tip {
  border-left-color: var(--color-tip);
}

.markdown-alert.markdown-alert-tip .markdown-alert-title {
  color: var(--color-tip);
}

.markdown-alert.markdown-alert-caution {
  border-left-color: var(--color-caution);
}

.markdown-alert.markdown-alert-caution .markdown-alert-title {
  color: var(--color-caution);
}

</style>
        
        </head>
        <body class="vscode-body vscode-light">
            <h2 id="what-we-will-study-next">What we will study next</h2>
<p>Most of this lesson's content is devoted to studying the ray-marching algorithm but you should know that while this algorithm was used almost exclusively for volume rendering until relatively recently (the mid-2010s at least), modern rendering engines are now generally using a <strong>stochastic Monte-Carlo</strong> based approach with it comes to rendering volumes instead. So why did we spend so much time studying this algorithm if it's considered superseded? For historical reasons and because it's much easier to get introduced to the topic of volume rendering (and the Volume Rendering Equation) through the ray-marching algorithm than through stochastic methods that are significantly more complex (particularly from the point of view of someone new to CGI programming with little to no math background).</p>
<p>Why is the ray-marching algorithm superseded? For essentially two reasons:</p>
<ol>
<li>
<p>because it poorly simulates how light behaves in the real world when it interacts with a volume. We will say more about this in a moment. Two, because the stochastic approach does a much better job of simulating the real thing.</p>
</li>
<li>
<p>We could have used the stochastic method right from the beginning then (this method is well known since the 1960s) but you see, the issue with this method is that it requires zillion times more computations than the ray-marching method and you had to wait an infinitely long time to produce an image with it (at least it felt that way). Ray-marching is computationally intensive but not as much as the stochastic method and that's why it stayed until recently the go-to solution for volume rendering (and even then we had to wait until the very late 1990s to start seeing ray-marching being used in production and until the late 2000s to start seeing it used ubiquitously). Thankfully with the continuous rise in computing power, we can now produce results with the stochastic method within reasonable times, and since it creates better results, the ray-marching method has been phased out in favor of stochastic-based approaches instead. <em>Quod erat demonstrandum</em>.</p>
</li>
</ol>
<p>Let's now look at why ray-marching does a rather poor job.</p>
<p>To answer this question, we need to understand how light travels through a medium. Here is what happens to a photon that enters a volume. It travels in a straight line for a certain distance until it eventually interacts with the medium (for example a particle making up the volume). As we know it can then be scattered (in which case it would change direction) or be absorbed. If it is scattered, it will then continue to travel through the volume but in a random direction, at least a direction that is very likely different from the direction it followed before interacting with the volume's particle. This &quot;travel-interact&quot; cycle keeps going for as long as the particle either gets absorbed or eventually leaves the volume. We have illustrated this idea in the image below, where you can see the fate of three photons entering a volume cube from the top.</p>
<p><img src="file:////images/volume-rendering-developers/voldev-multiple-scattering1.png?" alt=""></p>
<p>Two of them (in red) get eventually absorbed, while only one of them (green) escapes the volume (in a direction that's different from the direction it followed when entering the cube).</p>
<p>Photons follow what can be described as a kind of <strong>random walk</strong>. And no surprise, that's actually what it is called. A random walk. We also can see that the particle interacts with the medium multiple times before either being absorbed or escaping the volume. It's scatted multiple times. And that's where the ray-marching does a poor job: it only accounts for a single interaction between the photon and the volume.</p>
<h2 id="single-vs-multiple-scattering-low-vs-high-albedo-volume-objects">Single vs Multiple Scattering. Low vs. High Albedo Volume Objects.</h2>
<p>This is called single scattering. We only account for the light that's being redirected toward the viewer after a single interaction with the medium. While some volumes have a strong single scattering term (such as the dark smoke coming out of stream trains or volcanoes) many other types of volume, most notably clouds, exhibit a strong <strong>multiple scattering</strong> behavior. Photons interact with the object many many times before escaping (or being absorbed). This is what makes clouds so bright or white if you prefer, whereas the smoke coming out of steam trains or volcanoes is dark instead. We say that white clouds have a <strong>high albedo</strong> while dark smoke plumes have a <strong>low albedo</strong>. The image below shows the difference between a low and high albedo volume (the smoke on the left contains a lot of particles, whereas clouds are made out of water droplets which mostly explains the visual difference between the two). Of course, dark smoke is dark because it also absorbs a lot of light.</p>
<p><img src="file:////images/volume-rendering-developers/voldev-smokevscloud.png?" alt=""></p>
<p>In summary, the ray-marching algorithm provides an acceptable approximation for low albedo objects (such as smoke) whose appearance is the result of the dominance of the single-scattering term (the orange ray depicted in the image below), whereas it provides a poor way of simulating the appearance of high albedo objects, whose appearance is the result of the dominance of multiple-scattering over single-scattering (most of the photons escaping the volume do so after interacting with the volume multiple times and not just one time as assumed with single scattering).</p>
<p><img src="file:////images/volume-rendering-developers/voldev-ray-marching-cloud1.png?" alt=""></p>
<p>By the way, since we are on the topic of comparing smoke and clouds, note also that smoke is generally isotropic while clouds exhibit a strong (forward) scattering behavior.</p>
<p>In a way, you can compare ray-marching to direct lighting. Direct lighting is better than no lighting at all (obviously) but certainly not as good as a scene rendered with direct and indirect lighting. With ray-marching, we are missing the indirect lighting part entirely. As the example below shows, indirect lighting is essential for creating photo-realistic images. Therefore the fact that the ray-marching algorithm cannot capture this effect is a big problem.</p>
<p><img src="file:////images/volume-rendering-developers/voldev-indirectlighting.png?" alt=""></p>
<p>This has a concrete practical implication: you will have to pump a lot more light (as in creating additional light sources in the scene) into the volume to simulate the appearance of a cloud for example, and thus cheat rather than having the computer do the physical accurate and thus right thing. But then the question is: what is the alternative, how do get to - do - the right thing?</p>
<h2 id="stochastic-based-or-tracking-methods">Stochastic-based or Tracking Methods</h2>
<p>Well, the right thing is to let the computer simulate the way the photons do interact with the medium. In other words, simulate the photons' random walk behavior. This method aims to <strong>track</strong> the path of photons as they travel through the volume. This is why these methods are called <strong>tracking methods</strong>. This is not a &quot;new&quot; method. It was developed in the 1960s to simulate the radiation of particles such as neutrons for instance through plates. While versatile and very powerful this method is also very computationally expensive.</p>
<p>If you are interested to learn more about the topic on your own, search for Monte Carlo particle transport (MCPT) or Monte Carlo light or photon transport on the Internet. We won't go into the detail of this technique here. First, we are already providing a practical implementation of this method as an example of Monte Carlo simulation on this page: <a href="/lessons/mathematics-physics-for-computer-graphics/monte-carlo-methods-in-practice/monte-carlo-simulation">Monte Carlo Simulation</a>. We also plan to write a lesson about it hopefully soon (2022). Check the Advanced 3D Rendering section for updates (the lesson should be called Volumetric Path Tracing).</p>
<p>Let's just say for now that the idea is to simulate the path of photons through the volume. The goal remains to solve the <a href="/lessons/3d-basic-rendering/volume-rendering-for-developers/volume-rendering-summary-equations">volume rendering equation</a>:</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mo>∫</mo><mrow><msup><mi>s</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>=</mo><mn>0</mn></mrow><mi>s</mi></msubsup><mi>T</mi><mo stretchy="false">(</mo><msup><mi>s</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo><mo fence="false" stretchy="true" minsize="1.2em" maxsize="1.2em">[</mo><msub><mi>σ</mi><mi>s</mi></msub><msub><mi>L</mi><mi>s</mi></msub><mo stretchy="false">(</mo><msup><mi>s</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo><mo fence="false" stretchy="true" minsize="1.2em" maxsize="1.2em">]</mo><mi>d</mi><msup><mi>s</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>+</mo><mi>T</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mi>L</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L(s) = \int_{s&#x27;=0}^s T(s&#x27;)\big[\sigma_s L_s(s&#x27;) \big]ds&#x27; + T(s)L(0)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.3262em;vertical-align:-0.9119em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4143em;"><span style="top:-1.7881em;margin-left:-0.4445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.8129em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord"><span class="delimsizing size1">[</span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord"><span class="delimsizing size1">]</span></span><span class="mord mathnormal">d</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span></span></span></span></span></p>
<p>Using Monte Carlo (see <a href="/lessons/mathematics-physics-for-computer-graphics/monte-carlo-methods-mathematical-foundations/">Mathematical Foundations of Monte Carlo Methods</a> and <a href="/lessons/mathematics-physics-for-computer-graphics/monte-carlo-methods-in-practice/">Monte Carlo Methods in Practice</a> to learn more about this topic). As with ray tracing, we will <strong>not</strong> do so by simulating and tracking the path of photons as they travel forward (from the light source to the viewer or sensor) but <strong>backward</strong> from the viewer to the light source. The path of a particle through the medium can be characterized by a series of steps taken by the photon where each step in that path is defined by a length and a direction. We will randomly sample the length of the direction of the photons to account for this behavior using essentially the knowledge we have about the medium itself, and notably its scattering and absorption coefficients as well as its phase function.</p>
<p>Stochastic-based methods for Monte Carlo simulation or integration are computationally expensive as mentioned earlier. Techniques such as <strong>delta tracking</strong> which you may have heard of can be used to improve the process (at the cost of adding complexity to the code). Delta tracking will be studied in the lesson devoted to volumetric path tracing as well.</p>

            <script async src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
            
        </body>
        </html>