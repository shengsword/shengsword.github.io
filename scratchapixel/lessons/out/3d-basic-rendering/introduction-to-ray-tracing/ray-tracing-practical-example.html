<!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>A Minimal Ray Tracer</title>
            <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

</style>
            
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
<style>
:root {
  --color-note: #0969da;
  --color-tip: #1a7f37;
  --color-warning: #9a6700;
  --color-severe: #bc4c00;
  --color-caution: #d1242f;
  --color-important: #8250df;
}

</style>
<style>
@media (prefers-color-scheme: dark) {
  :root {
    --color-note: #2f81f7;
    --color-tip: #3fb950;
    --color-warning: #d29922;
    --color-severe: #db6d28;
    --color-caution: #f85149;
    --color-important: #a371f7;
  }
}

</style>
<style>
.markdown-alert {
  padding: 0.5rem 1rem;
  margin-bottom: 16px;
  color: inherit;
  border-left: .25em solid #888;
}

.markdown-alert>:first-child {
  margin-top: 0
}

.markdown-alert>:last-child {
  margin-bottom: 0
}

.markdown-alert .markdown-alert-title {
  display: flex;
  font-weight: 500;
  align-items: center;
  line-height: 1
}

.markdown-alert .markdown-alert-title .octicon {
  margin-right: 0.5rem;
  display: inline-block;
  overflow: visible !important;
  vertical-align: text-bottom;
  fill: currentColor;
}

.markdown-alert.markdown-alert-note {
  border-left-color: var(--color-note);
}

.markdown-alert.markdown-alert-note .markdown-alert-title {
  color: var(--color-note);
}

.markdown-alert.markdown-alert-important {
  border-left-color: var(--color-important);
}

.markdown-alert.markdown-alert-important .markdown-alert-title {
  color: var(--color-important);
}

.markdown-alert.markdown-alert-warning {
  border-left-color: var(--color-warning);
}

.markdown-alert.markdown-alert-warning .markdown-alert-title {
  color: var(--color-warning);
}

.markdown-alert.markdown-alert-tip {
  border-left-color: var(--color-tip);
}

.markdown-alert.markdown-alert-tip .markdown-alert-title {
  color: var(--color-tip);
}

.markdown-alert.markdown-alert-caution {
  border-left-color: var(--color-caution);
}

.markdown-alert.markdown-alert-caution .markdown-alert-title {
  color: var(--color-caution);
}

</style>
        
        </head>
        <body class="vscode-body vscode-light">
            <p>We received quite a few emails from readers asking, &quot;Well, if that's so easy to do, can't you provide us with a real example?&quot; That was different from the plan (since the idea is to write the renderer step-by-step), but we wrote a minimalistic ray tracer which is about 300 hundred lines in about a couple of hours. Although we are not necessarily proud of that performance, we want to show that when one knows these techniques well, implementing them is not difficult. The source code is available for download. We did not and will not spend time commenting on this program. It was written relatively quickly, so there is room for improvement. In this version of the raytracer, we made the light visible (a sphere), so its reflection would appear in the reflective balls. It is sometimes hard to see when glass spheres are transparent (white), so in our example, we tinted them slightly (red). In the real world, clear glass is not necessarily visible. It depends on the environment. Note that the resulting image needs to be more accurate. The shadow under the transparent red sphere should not be completely opaque. In future lessons, we will learn how to correct this visual inaccuracy quickly. We also implemented other features such as a fake fresnel (using a technique called the facing ratio) and refraction. All these things will be studied later, so feel free to if you need help understanding them clearly. At least you now have a small program to play with.</p>
<p>To compile the program, download the source code to your hard drive. You will need a c++ compiler (such as clang++). This program doesn't need anything particular to get compiled. Take a terminal (e.g., GitBash for Windows or just a terminal under Linux or macOS) and type the following command (if you use gcc) where your file lives:</p>
<pre><code>c++ -O3 -o raytracer raytracer.cpp
</code></pre>
<p>If you use clang, use the following command instead:</p>
<pre><code>clang++ -O3 -o raytracer raytracer.cpp
</code></pre>
<p>To create an image, run the program by typing <code>./raytracer</code> in a shell. Wait a few seconds. When the program returns, you should have a file called untitled.ppm on your disk. You can open this file with Photoshop, Preview (on Mac), or Gimp (a lesson is devoted to reading and displaying PPM images).</p>
<p>Here is one possible implementation of the classical recursive ray-tracing algorithm in pseudo-code:</p>
<pre><code>#define MAX_RAY_DEPTH 3 
 
color Trace(const Ray &amp;ray, int depth) 
{ 
    Object *object = NULL; 
    float minDist = INFINITY; 
    Point pHit; 
    Normal nHit; 
    for (int k = 0; k &lt; objects.size(); ++k) { 
        if (Intersect(objects[k], ray, &amp;pHit, &amp;nHit)) { 
            // ray origin = eye position of the prim ray
            float distance = Distance(ray.origin, pHit); 
            if (distance &lt; minDistance) { 
                object = objects[i]; 
                minDistance = distance; 
            } 
        } 
    } 
    if (object == NULL) 
        return 0; 
    // if the object material is glass, split the ray into a reflection
    // and a refraction ray.
    if (object-&gt;isGlass &amp;&amp; depth &lt; MAX_RAY_DEPTH) { 
        // compute the reflection
        Ray reflectionRay; 
        reflectionRay = computeReflectionRay(ray.direction, nHit); 
        // recurse
        color reflectionColor = Trace(reflectionRay, depth + 1); 
        Ray refractioRay; 
        refractionRay = computeRefractionRay( 
            object-&gt;indexOfRefraction, 
            ray.direction, 
            nHit); 
        // recurse
        color refractionColor = Trace(refractionRay, depth + 1); 
        float Kr, Kt; 
        fresnel( 
            object-&gt;indexOfRefraction, 
            nHit, 
            ray.direction, 
            &amp;Kr, 
            &amp;Kt); 
        return reflectionColor * Kr + refractionColor * (1-Kr); 
    } 
    // object is a diffuse opaque object        
    // compute illumination
    Ray shadowRay; 
    shadowRay.direction = lightPosition - pHit; 
    bool isShadow = false; 
    for (int k = 0; k &lt; objects.size(); ++k) { 
        if (Intersect(objects[k], shadowRay)) { 
            // hit point is in shadow so return
            return 0; 
        } 
    } 
    // point is illuminated
    return object-&gt;color * light.brightness; 
} 
 
// for each pixel of the image
for (int j = 0; j &lt; imageHeight; ++j) { 
    for (int i = 0; i &lt; imageWidth; ++i) { 
        // compute primary ray direction
        Ray primRay; 
        computePrimRay(i, j, &amp;primRay); 
        pixels[i][j] = Trace(primRay, 0); 
    } 
}
</code></pre>
<p><img src="file:////images/introduction-to-ray-tracing/raytrace1.png" alt="Figure 1: Result of our ray tracing algorithm."></p>
<h2 id="a-minimal-ray-tracer">A Minimal Ray Tracer</h2>
<p><img src="file:////images/introduction-to-ray-tracing/aek.png" alt="Figure 2: Result of our Paul Heckbert's ray tracing algorithm."></p>
<p>Many years ago, researcher Paul Heckbert wrote a ray tracer that could &quot;fit on a business card&quot;. The idea was to write a minimal ray tracer in C/C++, so small that he could print it out on the back of his business card (more information on this idea can be found in an article he wrote in Graphics Gems IV). Many programmers since then have tried this coding exercise. Below, you can find a version written by Andrew Kensler. The image on the left is the result of his program. Note the depth of field effect (objects get blurred in the distance). Creating a reasonably complex image with such few lines of code is fantastic.</p>
<pre><code class="language-wrap">// minray &gt; minray.ppm
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
typedef int i;typedef float f;struct v{f x,y,z;v operator+(v r){return v(x+r.x,y+r.y,z+r.z);}v operator*(f r){return v(x*r,y*r,z*r);}f operator%(v r){return x*r.x+y*r.y+z*r.z;}v(){}v operator^(v r){return v(y*r.z-z*r.y,z*r.x-x*r.z,x*r.y-y*r.x);}v(f a,f b,f c){x=a;y=b;z=c;}v operator!(){return*this*(1/sqrt(*this%*this));}};i G[]={247570,280596,280600,249748,18578,18577,231184,16,16};f R(){return(f)rand()/RAND_MAX;}i T(v o,v d,f&amp;t,v&amp;n){t=1e9;i m=0;f p=-o.z/d.z;if(.01&lt;p)t=p,n=v(0,0,1),m=1;for(i k=19;k--;)for(i j=9;j--;)if(G[j]&amp;1&lt;&lt;k){v p=o+v(-k,0,-j-4);f b=p%d,c=p%p-1,q=b*b-c;if(q&gt;0){f s=-b-sqrt(q);if(s&lt;t&amp;&amp;s&gt;.01)t=s,n=!(p+d*t),m=2;}}return m;}v S(v o,v d){f t;v n;i m=T(o,d,t,n);if(!m)return v(.7,.6,1)*pow(1-d.z,4);v h=o+d*t,l=!(v(9+R(),9+R(),16)+h*-1),r=d+n*(n%d*-2);f b=l%n;if(b&lt;0||T(h,l,t,n))b=0;f p=pow(l%r*(b&gt;0),99);if(m&amp;1){h=h*.2;return((i)(ceil(h.x)+ceil(h.y))&amp;1?v(3,1,1):v(3,3,3))*(b*.2+.1);}return v(p,p,p)+S(h,r)*.5;}i main(){printf(&quot;P6 512 512 255 &quot;);v g=!v(-6,-16,0),a=!(v(0,0,1)^g)*.002,b=!(g^a)*.002,c=(a+b)*-256+g;for(i y=512;y--;)for(i x=512;x--;){v p(13,13,13);for(i r=64;r--;){v t=a*(R()-.5)*99+b*(R()-.5)*99;p=S(v(17,16,8)+t,!(t*-1+(a*(R()+x)+b*(y+R())+c)*16))*3.5+p;}printf(&quot;%c%c%c&quot;,(i)p.x,(i)p.y,(i)p.z);}}
</code></pre>
<p>To run the program, copy/paste the code into a text file (rename the file, for instance, minray.cpp or anything you like), then compile the code (<code>c++ -O3 -o minray minray.cpp</code> or <code>clang++ -O3 -o minray minray.cpp</code> if you prefer the clang compiler) and run it with the command line: <code>minray &gt; minray.ppm</code>. Rather than writing the final image data to disk, which would make the code longer, the data is just written out to the standard output (the shell from which you are running the program), which we can redirect (with the sign &gt;) to a file. The PPM file can be read with Photoshop.</p>
<p>This program is only presented here to show that the ray tracing algorithm can be implemented with very few lines of code. Many of the techniques used in the code are explained in the following lessons of this section.</p>

            
            
        </body>
        </html>